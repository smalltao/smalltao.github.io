---
layout: post
title:  "java 面试题"
subtitle:   "一些 java 面试题"
author:     "LiTao"
date:   2018-06-16 07:28:33 +0800
categories: java
catalog:    true
tags:
    - java
---

## hashcode相等的两个类一定相等吗? equals呢? 相反呢?

hashcode相等的两个类不一定相等，hashcode值通过杂凑法得到，两个不同对类对象hashcode值也是可能相等的，== 比较的是对象的内存引用地址，equals默认比较的也是内存的引用地址，但是在Integer、String等类种对equals比较的是引用地址的值

## 介绍一下集合框架?

一、集合与数组

数组（可以存储基本数据类型），是用来存现对象的一种容器、当时数组长度固定、不适合在对象数量未知的情况下使用

集合（只能存储对象，对象类型可以不一样），长度可变，适合大多数场景

二、层次关系

Collection 接口是集合类的根接口，java中没有提供这个接口的直接实现类。但是却让其被继承产出了两个子接口、就是Set和List。

Set中不能包含重复的元素，List是一个有序集合，可以包含重复的元素，提供了按索引访问的方式

Map是Java.util包中的另一个接口、它和Collection 接口没有关系，是相互独立的，但是都属于集合类的一部分

Map包含了key-value对，Map不能包含重复的key，但是可以包含重复的值

Iterator： 所有的集合类都实现了iterator接口，这是用于遍历集合中元素的接口，主要包含三种方法：

1. hasNest() 是否还有下一个
2. next() 返回下一个元素
3. remove() 删除当前元素

三、几种重要的接口和类介绍

1. List （有序、可重复）

List 里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引有关的方法、查询速度快。
因为向list集合里插入和删除数据时，会伴随着后面数据的移动，所以插入和删除数据慢

2. Set (无序，不能重复)

Set 里存放的数据是无序，不能重复，集合内的对象不安特定的方式排序，只是简单的把对象加入集合

3. Map （健值对，健唯一、值不唯一）

Map集合存储的是健值对、健唯一、值不唯一、根据健得到值、对map集合遍历时先得到健的set集合，对set集合遍历得到相应的值

四、常用集合

实现类：HashMap、HashTable、LinkedHashTable、treeMap等

HashMap 根据hashcode 值存储数据，根据健可以直接获取到它到值，具有很快的访问速度，遍历时取得数据的顺序完全随机的，
应为健对象不可以重复，随意HashMap最多允许一条记录的健为Null，允许多条记录的值为Null，是非同步的

HashTable 是线程安全的，支持线程的同步，即任一时刻只能有一个线程写HashTable，所以HashTable在写入时会慢，
它继承自Dictionary类，不同的时它允许健值为Null，同时效率低下

ConcurrentHashMap 线程安全同时锁分离，ConcurrentHashMap内部使用段（Segment）来表示不同的部分，
每个段就是一个小的HashTable，它们有自己的锁，只要多个修改操作发生在不同的段上，就可以并发执行

LinkedHashMap  保存了记录的插入顺序，在用Iterator遍历LingkedHashMap时，先得到的内容肯定是先插入的，在遍历的时候会比HashMap慢，有hashMap的全部特性

TreeMap 实现SortMap 接口，能够把保存的记录按健排序，默认是按健值的升序排序（自然排序），也可以制定排序比较器，，不允许key值为Null，非同步

ArrayList和Linkedlist

用法上没有区别，功能上有区别。Linkedlist经常用在增删较多和查询较少的情况下，ArrayList相反

主要实现类区别

1. Vector和ArrayList

1.1. Vector 是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，不是线程安全的，一般ArrayList效率高

1.2 如果集合中的元素的数目大于目前集合数组的长度时，Vector增长率为目前数组长度的100%，而ArrayList增长率为目前数组长度的是50%
如果在集合中使用数据量比较大的数据，用Vecto比较有优势

1.3 如果查找一个指定位置的数据，Vector和ArrayList使用的时间是相同的，

## hashmap hastable 底层实现什么区别? hashtable 和 concurrenthashtable 底层实现有什么区别呢?

1. HashMap 工作原理，hashing（散列法）原理，通过put()、get()方法存储和获取对象，当我们把健值对传递给put方法的时候，
它调用健对象的hashCode方法计算hashcode值，然后找到buket位置来存储值对象。当获取对象时，通过健对象的equal()方法找到正确的健值对
，然后返回对象。HashMap使用链表来解决碰撞问题，当发生碰撞时，对象将会存储在链表对下一个节点中，HashMap在每个链表节点中存储健值对对象

当两个不同对象对hashcode相同时，它们会存储在同一个buket位置的链表中，健对象的equals方法找到健值对

2. HashMap 和 HashTable 对区别

HashMap 和HashTable都实现了 Map 接口，主要区别是：线程安全（synchronzation），以及速度

http://www.cnblogs.com/beatIteWeNerverGiveUp/p/5709841.html

1. hashMap 底层实现原理

4、hashmap 和treemap 什么区别? 底层数据结构是什么?

## 线程池都有什么参数? 底层如何实现的?

corePoolSize 核心线程大小，创建线程池之后，默认线程池中并没有任何线程，，而是等待有任务到来才去创建线程执行任务，除非执调用了
preStartAllCoreTreads()或者preStartCoreThread()方法，这两个方法是在任务到来之前提前创建corePool里的线程

maxPoolSize 线程池最大线程数，当线程数大于等于核心线程数时，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maxPoolSize。
如果线程数等于maxPoolSize，且任务队列已满，超出线程池处理能力，默认情况下，线程池会拒绝执行任务抛出异常

keepAliveTme 线程存活时间，当线程空闲时间达到keepAliveTime，该先线程会推出，直到线程数量等于corePoolSize，
如果设置了allowCoreThreadTimeout为true，则所有线程均会退出，直达线程数量为0

allowCoreThreadTimeout 是否允许核心线程空闲退出

queueCapacity 队列容量 ，任务队列容量

workQueue 工作队列， 一个阻塞队列，用来存储等待执行等任务

线程工厂

拒绝策略

6、sychnized和Lock什么区别? sychnize 什么情况情况是对象锁? 什么时候是全局锁为什么?

7、ThreadLocal 是什么底层如何实现?写一个例子呗?

8、volitile 的工作原理?

9、cas知道吗？如何实现的?

10、请用至少四种写法写一个单例模式?

JVM
1、请介绍一下JVM内存模型? 用过什么垃圾回收器都说说呗



2、线上发送频繁full gc如何处理? CPU 使用率过高怎么办?



如何定位问题? 如何解决说一下解决思路和处理方法



## 知道字节码吗? 字节码都有哪些? Integer x = 5,int y = 5，比较 x = y 都经过哪些步骤?

>> 通过 java 语言编写的java文件，经过编译之后得到的（.class）就是字节码文件

```
public class demo{

  private int a = 1;

  protected void testMethod() {

  }

}

```

通过javac 命令 或ide 工具编译java文件为class文件得到字节码文件：一堆16进制字节


### 讲讲类加载机制，都有哪些类加载器，这些类加载器都加载哪些文件?

>> jvm 类加载机制分为5个部分，加载、验证、准备、解析、初始化

加载（loading） >> 验证（verification）>> 准备（preparation） >> 解析（resolution） >> 初始化（initialization） >> 使用（using） >> 卸载（unloading）  

连接（linking）[验证、准备、解析]

1. 加载

加载是类加载过程的一个阶段，这个阶段会在内存中生成一个代表这个类的的java.lang.Class 对象，作为方法取这个类的各种数据的入口。注意这个类不一定非要从一个class获取，这里可以从zip、或着war包读取，也可以运行时计算生成（动态代理），也可以由其他文件生成（比如将jsp转换为对应的class类）

2. 验证

这一阶段主要是为了确保class文件的字节流包含的信息是否符合当前虚拟机的要求，并且不回危害虚拟机自身的安全

3. 准备

准备阶段正式为类变量分配内存并设置类变量的初始值阶段，即在方法区分配这些变量所使用的内存空间，

4. 解析

5. 初始化

jvm 提供了三种类加载器，

1. 启动类加载器

负责加载 JAVA_HOME/lib 目录下，或者通过Xbootclasspath 参数指定的，并虚拟机认可的类（按文件名称，如rt.jar）

2. 扩展类加载器

负责加载 JAVA_HOME/lig/ext 目录中，或通过java.ext.dirs 系统变量指定路径中的类库

3. 应用程序类加载器

负责加载用户路径classpath目录下的文件

JVM 通过双亲委派模型进行类的加载，也可以通过java.lang.ClassLoader实现自定义类加载器

手写一下类加载Demo？

5、知道osgi吗? 他是如何实现的???

6、请问你做过哪些JVM优化?使用什么方法达到什么效果???

7、classforName('java.lang.String')和String classgetClassLoader() LoadClass('java.lang.String') 什么区别啊??

￼

JVM
Spring
1、spring都有哪些机制啊 AOP底层如何实现的啊IOC呢??

2、cgLib知道吗? 他和jdk动态代理什么区别? 手写一个jdk动态代理呗?

数据库

### 使用mysq1索引都有哪些原则? 索引什么数据结构? 3 tree 和Btree 什么区别?

1. 选择唯一性原则

唯一索引的值是唯一的，可以更快速的通过该所以来确定某条记录，如：学生表中学好是具有唯一性的字段，为该字段建立唯一索引可以很快的确定某个学生的信息。如果使用姓名的话可能出现同名现象，从而降低查询速度

2. 为经常需要排序、分组、联合操作的字段建立索引

经常需要order by、group by、distinct、union 的字段排序会浪费很多时间，如果为其建立所以可以有效的避免排序操作。

3. 为常做查询条件的字段建立索引

如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度，因此，为这样的字段建立索引，可以提高整个表的查询速度

4. 限制索引的数目

索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大，修改表时对索引的重构和更新就越麻烦，越多的表会使表更新变的很耗时

5. 尽量使用数据量少的索引

如果索引的值很长，那么查询的速度会受影响。例如对一个CHAR（100）类型的字段进行全文检索需要的时间肯定要比对CHAR（10）类型的字段需要的时间要多

6. 尽量使用前缀来索引

如果索引字段的值很长，最好使用值的前缀来索引，例如，text和blog类型的字段， 进行全文检索会浪费时间，如果只检索字段的前面的若干个字符，，这样可以提高检索速度

7. 删除不再使用或者很少使用的索引

表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要，数据库管理员应定期找到这些索引，将它们删除，从而减少索引对更新操作的影响

8. 最左前缀匹配原则（重要）

mysql 会一直向右匹配直到遇到范围查询（> , < , between, like）就停止匹配，比如：a="" and b="3" and c>3 and d=4 ,如果建立（a,b,c,d）顺序的索引，d是用不到索引的，如果建立（a,b,d,c）的索引则可以用到，a,b,d的顺序可以任意调整

9. = 和 in 可以乱序

比如：a=1 and b=2 and c=3 ,建立索引（a,b,c）索引可以任意顺序，mysql查询优化器会帮你优化索引可以识别的形式

10. 尽量选择区分度高的列作为索引

区分度高的公式是count(distinct col)/count(\*) ,表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一健的区分度是1， 而一些状态、性别字段在大数据面前区分度就是0

11. 索引不能参与计算，保持 `列` 干净

比如：from_unixtime(create_time) = '2014-05-29' 就不能使用索引，原因很简单，b+树中存的都是数据表中的字段值，当进行检索时，需要把所有元素都应用函数才能比较，显然成本太大，所以语句应该写成create_time=unix_timestamp('2014-05-29')

12. 尽量的扩展索引，不要新建索引

比如表中已经有a 的索引，现在要加（a,b）的索引，那么只需要修改原来的索引就好了

***注意：选择索引的目的是为了使查询的速度变快*** 

2、mysq1有哪些存储引擎啊? 都有啥区别? 要详细!

3、设计高并发系统数据库层面该怎么设计?  数据库锁有哪些类型?如何实现呀?

4、数据库事务有哪些?

分库分表
1、如何设计可以动态扩容缩容的分库分表方案?

2、用过哪些分库分表中间件，有啥优点和缺点? 讲一下你了解的分库分表中间件的底层实现原理?

3、我现在有一个未分库分表的系统，以后系统需分库分表，如何设计，让未分库分表的系统动态切换到分库分表的系统上???TCC? 那若出现网络原因，网络连不通怎么办啊???

4、分布式事务知道吗? 你们怎么解决的?

5、为什么要分库分表啊???

6、分布式寻址方式都有哪些算法知道一致性hash吗?手写一下java实现代码??你若userId取摸分片，那我要查一段连续时间里的数据怎么办???

7、如何解决分库分表主键问题有什么实现方案??

分布式缓存
1、redis和memcheched 什么区别，为什么单线程的redis比多线程的memched效率要高啊?

2、redis有什么数据类型都在哪些场景下使用啊?

3、reids的主从复制是怎么实现的？redis的集群模式是如何实现的呢？redis的key是如何寻址的啊?

4、使用redis如何设计分布式锁?使用zk可以吗?如何实现啊这两种哪个效率更高啊??
5、知道redis的持久化吗都有什么缺点优点啊? ?具体底层实现呢?
6、redis过期策略都有哪些LRU 写一下java版本的代码吧??

分布式服务框架
1、说一下dubbo的实现过程注册中心挂了可以继续通信吗??
2、zk原理知道吗zk都可以干什么Paxos算法知道吗?说一下原理和实现??
3、dubbo支持哪些序列化协议?hessian 说一下hessian的数据结构PB知道吗为啥PB效率是最高的啊??
4、知道netty吗'netty可以干嘛呀NIO,BIO,AIO 都是什么啊有什么区别啊?
5、dubbo复制均衡策略和高可用策略都有哪些啊动态代理策略呢?
6、为什么要进行系统拆分啊拆分不用dubbo可以吗'dubbo和thrift什么区别啊?

分布式消息队列
1、为什么使用消息队列啊消息队列有什么优点和缺点啊?
2、如何保证消息队列的高可用啊如何保证消息不被重复消费啊
3、kafka ，activemq,rabbitmq ，rocketmq都有什么优点，缺点啊???
4、如果让你写一个消息队列，该如何进行架构设计啊?说一下你的思路

分布式搜索引擎
1、es的工作过程实现是如何的?如何实现分布式的啊
2、es在数据量很大的情况下( 数十亿级别)如何提高查询效率啊?
3、es的查询是一个怎么的工作过程? 底层的lucence介绍一下呗 倒排索引知道吗? es和mongdb什么区别啊都在什么场景下使用啊?

高并发高可用架构设计

1、如何设计一个高并发高可用系统

2、如何限流?工程中怎么做的，说一下具体实现

3、缓存如何使用的缓存使用不当会造成什么后果?

4、如何熔断啊?熔断框架都有哪些?具体实现原理知道吗?

5、如何降级如何进行系统拆分，如何数据库拆分????

分布式专题架构

通信协议
1、说一下TCP 'IP四层?

2、http的工作流程?? ?http1.0 http1.1http2.0 具体哪些区别啊?

3、TCP三次握手，四层分手的工作流程画一下流程图为什么不是四次五次或者二次啊?

4、画一下https的工作流程?具体如何实现啊?如何防止被抓包啊?

算法
1、比较简单，我一个文件，有45亿个阿拉伯数字，如何进行去重啊如何找出最大的那个数啊?

数据结构

1、二叉树和红黑树等。

源码中所用到的经典设计思想及常用设计模式
